"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = __importDefault(require("fs"));
var core = __importStar(require("@actions/core"));
var exec = __importStar(require("@actions/exec"));
/*
 * -------------------------------------------------------------------------------------------------------------------
 * - Constants. ------------------------------------------------------------------------------------------------------
 * -------------------------------------------------------------------------------------------------------------------
 */
/**
 * The regular expression that represents a version release.
 *
 * For example, `v0.11.5-beta+17-2020-05-12` will provide parts:
 *
 * - `0`: `0`
 * - `1`: `11`
 * - `2`: `5`
 * - `3`: `-beta+17-2020-05-12`
 */
exports.SEMVER_REGEXP = /v?(?<major>\d+)\.(?<minor>\d+)\.(?<patch>\d+)(?<info>.*)/;
/*
 * -------------------------------------------------------------------------------------------------------------------
 * - Classes. --------------------------------------------------------------------------------------------------------
 * -------------------------------------------------------------------------------------------------------------------
 */
/** A [RegExp] to [string] replacement map for use on a file. */
var ReplacementMap = /** @class */ (function () {
    function ReplacementMap(matcher, replacement) {
        this.matcher = matcher;
        this.replacement = replacement;
    }
    return ReplacementMap;
}());
exports.ReplacementMap = ReplacementMap;
;
/** A basic concrete representation of a Semantic Version. */
var SemVer = /** @class */ (function () {
    function SemVer(major, minor, patch, info) {
        this._major = major;
        this._minor = minor;
        this._patch = patch;
        this._info = info;
    }
    Object.defineProperty(SemVer.prototype, "major", {
        get: function () {
            return this._major;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SemVer.prototype, "minor", {
        get: function () {
            return this._minor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SemVer.prototype, "patch", {
        get: function () {
            return this._patch;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SemVer.prototype, "info", {
        get: function () {
            return this._info;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * From a textual version, create a [SemVer].
     *
     * These might be something like `0.31.5` or `2.0.0-some_info_here+2020-03-01`, for example.
     *
     * @param text the textual version
     */
    SemVer.constructFromText = function (text) {
        var match = text.match(exports.SEMVER_REGEXP);
        if (!match) {
            throw Error("Provided text is not valid SemVer: [" + text + "]");
        }
        var groups = match.groups;
        var major = parseInt(groups["major"]);
        var minor = parseInt(groups["minor"]);
        var patch = parseInt(groups["patch"]);
        /* Force set to null if falsey (empty string). */
        var info = groups["info"] || null;
        return new SemVer(major, minor, patch, info);
    };
    /**
     * Return the "zero version" as a [SemVer].
     */
    SemVer.constructZero = function () {
        return new SemVer(0, 0, 0, null);
    };
    /**
     * Find the largest of any number of [[SemVer]]s.
     *
     * @param versions the [[SemVer]]s for which to find the maximum
     */
    SemVer.max = function (versions) {
        var runningMax = SemVer.constructZero();
        if (versions.length === 0) {
            core.warning("[Autolib] Running SemVer.max with an empty array. Returning 0.0.0.");
        }
        versions.forEach(function (version) {
            runningMax = SemVer.compare(version, runningMax);
        });
        return runningMax;
    };
    /**
     * Return the larger of two [[SemVer]]s.
     *
     * @param left a [[SemVer]]
     * @param right a [[SemVer]]
     */
    SemVer.compare = function (left, right) {
        var majorIsSame = left.major == right.major;
        var majorIsLeft = left.major > right.major;
        var minorIsSame = left.minor == right.minor;
        var minorIsLeft = left.minor > right.minor;
        var patchIsSame = left.patch == right.patch;
        var patchIsLeft = left.patch > right.patch;
        /* Is minor greater? */
        var minorIncremented = majorIsSame && minorIsLeft;
        /* Is minor the same and the left patch is greater? */
        var patchIncremented = !minorIncremented && minorIsSame && patchIsLeft;
        /* Failing that, is the left version stable and the right version unstable? */
        var versionStabilized = (!patchIncremented && patchIsSame && left.info === null && right.info !== null);
        /* Failing that, is the left version's version lexically greater? */
        var infoIncremented = (!versionStabilized && left.info != null && right.info != null && left.info.localeCompare(right.info) === 1);
        if (majorIsLeft || minorIncremented || patchIncremented || versionStabilized || infoIncremented) {
            return left;
        }
        return right;
    };
    /**
     * Return "true" if this is a "zero version".
     */
    SemVer.prototype.isZero = function () {
        return (this.major === 0 && this.minor === 0 && this.patch === 0 && this.info == null);
    };
    SemVer.prototype.toString = function () {
        var representation = this.major + "." + this.minor + "." + this.patch;
        if (this.info) {
            return "" + representation + this.info;
        }
        return representation;
    };
    return SemVer;
}());
exports.SemVer = SemVer;
;
/*
 * -------------------------------------------------------------------------------------------------------------------
 * - Utilities. ------------------------------------------------------------------------------------------------------
 * -------------------------------------------------------------------------------------------------------------------
 */
/**
 * Given a file, perform replacements based on the [ReplacementMap] and write.
 *
 * @param filename the file's name
 * @param replacements the [Array] of [ReplacementMap]s
 */
function rewriteFileContentsWithReplacements(filename, replacements) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            fs_1.default.exists(filename, function (exists) {
                if (exists) {
                    /* If the file exists, we can perform the replacement by reading from the file first: */
                    fs_1.default.readFile(filename, function (_, data) {
                        var replaced = data.toString();
                        replacements.forEach(function (replaceMap) {
                            replaced = replaced.replace(replaceMap.matcher, replaceMap.replacement);
                        });
                        fs_1.default.writeFile(filename, replaced, function (_) { return null; });
                    });
                }
                else {
                    /* If the file does not exist, we produce a warning and stop. */
                    core.warning("[Autolib] Cannot perform replace-rewrite of file that does not exist: " + filename + ".");
                }
            });
            return [2 /*return*/];
        });
    });
}
exports.rewriteFileContentsWithReplacements = rewriteFileContentsWithReplacements;
/**
 * Given a file, perform a single replacement based on the matcher and replacement.
 *
 * @param filename the file's name
 * @param matcher the matcher [RegExp]
 * @param replacement the replacement [string]
 */
function rewriteFileContentsWithReplacement(filename, matcher, replacement) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            rewriteFileContentsWithReplacements(filename, [new ReplacementMap(matcher, replacement)]);
            return [2 /*return*/];
        });
    });
}
exports.rewriteFileContentsWithReplacement = rewriteFileContentsWithReplacement;
/**
 * Given [string] of newline-delimited tags in text, find the latest tag and return it as [[SemVer]].
 *
 * Note the example: `1.0.0-rc2 < 1.0.0`.
 *
 * @param text the text with tags from which to find the latest SemVer version
 * @param stableOnly if the function should ignore all prerelease/build info-appended versions
 * @returns a SemVer representation as a 4-ary [Tuple] of 3 [number]s and 1 optional [string]
 */
function findLatestSemVerUsingString(text, stableOnly) {
    return __awaiter(this, void 0, void 0, function () {
        var versionsInText, max;
        return __generator(this, function (_a) {
            versionsInText = text.split("\n")
                /* Remove surrounding whitespace from all tags. */
                .map(function (tag) { return tag.trim(); })
                /* Convert into SemVer or zeroed "invalid" version. */
                .map(function (tag) {
                try {
                    var candidate = SemVer.constructFromText(tag);
                    if (stableOnly && candidate.info) {
                        /* If in "stable-only" mode, versions with info strings are invalid. */
                        core.info("[Autolib] [Parse] " + tag + " is valid SemVer but it's not stable and this is stable mode.");
                        return SemVer.constructZero();
                    }
                    core.info("[Autolib] [Parse] " + tag + " is valid SemVer! Nice.");
                    return candidate;
                }
                catch (_a) {
                    core.info("[Autolib] [Parse] " + tag + " is invalid SemVer.");
                    return SemVer.constructZero();
                }
            })
                /* Filter out "zeroed" versions. */
                .filter(function (tag) { return !tag.isZero(); });
            max = SemVer.max(versionsInText);
            core.info("[Autolib] [Result] Of versions: [" + versionsInText.join(", ") + "], the " + (stableOnly ? "stable max" : "max") + " " +
                ("was found to be: [" + max + "]."));
            return [2 /*return*/, max];
        });
    });
}
exports.findLatestSemVerUsingString = findLatestSemVerUsingString;
/**
 * Using `git` tags, find the latest version (if this is possible).
 *
 * If no version is found, just return 0.0.0 with no info associated.
 *
 * @param stableOnly whether we should only extract stable versions
 */
function findLatestVersionFromGitTags(stableOnly) {
    return __awaiter(this, void 0, void 0, function () {
        var text, _a;
        var _this = this;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    text = null;
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 4, , 5]);
                    return [4 /*yield*/, exec.exec('git fetch --tags')];
                case 2:
                    _b.sent();
                    return [4 /*yield*/, exec.exec('git tag', [], {
                            listeners: {
                                stdout: function (data) { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, findLatestSemVerUsingString(data.toString(), stableOnly)];
                                            case 1:
                                                text = _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); }
                            }
                        })];
                case 3:
                    _b.sent();
                    return [3 /*break*/, 5];
                case 4:
                    _a = _b.sent();
                    core.warning("[Autolib] Compliant git tag cannot be found. Returning 0.0.0.");
                    return [3 /*break*/, 5];
                case 5:
                    if (!text) {
                        return [2 /*return*/, SemVer.constructZero()];
                    }
                    return [2 /*return*/, text];
            }
        });
    });
}
exports.findLatestVersionFromGitTags = findLatestVersionFromGitTags;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMENBQW9CO0FBRXBCLGtEQUFzQztBQUN0QyxrREFBc0M7QUFFdEM7Ozs7R0FJRztBQUVIOzs7Ozs7Ozs7R0FTRztBQUNVLFFBQUEsYUFBYSxHQUFXLDBEQUEwRCxDQUFDO0FBRWhHOzs7O0dBSUc7QUFFSCxnRUFBZ0U7QUFDaEU7SUFPSSx3QkFBWSxPQUFlLEVBQUUsV0FBbUI7UUFDNUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDdkIsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7SUFDbkMsQ0FBQztJQUNMLHFCQUFDO0FBQUQsQ0FBQyxBQVhELElBV0M7QUFYWSx3Q0FBYztBQVcxQixDQUFDO0FBRUYsNkRBQTZEO0FBQzdEO0lBNkhJLGdCQUFtQixLQUFhLEVBQUUsS0FBYSxFQUFFLEtBQWEsRUFBRSxJQUFtQjtRQUMvRSxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztJQUN0QixDQUFDO0lBckhELHNCQUFJLHlCQUFLO2FBQVQ7WUFDSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDdkIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSx5QkFBSzthQUFUO1lBQ0ksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3ZCLENBQUM7OztPQUFBO0lBRUQsc0JBQUkseUJBQUs7YUFBVDtZQUNJLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUN2QixDQUFDOzs7T0FBQTtJQUVELHNCQUFJLHdCQUFJO2FBQVI7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