/**
 * The regular expression that represents a version release.
 *
 * For example, `v0.11.5-beta+17-2020-05-12` will provide parts:
 *
 * - `0`: `0`
 * - `1`: `11`
 * - `2`: `5`
 * - `3`: `-beta+17-2020-05-12`
 */
export declare const SEMVER_REGEXP: RegExp;
/** A [RegExp] to [string] replacement map for use on a file. */
export declare class ReplacementMap {
    /** The regular expression to match and replace. */
    matcher: RegExp;
    /** The literal replacement to use to replace the given regular expression. */
    replacement: string;
    constructor(matcher: RegExp, replacement: string);
}
/** A basic concrete representation of a Semantic Version. */
export declare class SemVer {
    /** The major version, immutable. */
    private _major;
    /** The minor number, immutable. */
    private _minor;
    /** The patch number, immutable. */
    private _patch;
    /** The information string, if applicable, immutable. */
    private _info;
    get major(): number;
    get minor(): number;
    get patch(): number;
    get info(): string | null;
    /**
     * From a textual version, create a [SemVer].
     *
     * These might be something like `0.31.5` or `2.0.0-some_info_here+2020-03-01`, for example.
     *
     * @param text the textual version
     */
    static constructFromText(text: string): SemVer;
    /**
     * Return the "zero version" as a [SemVer].
     */
    static constructZero(): SemVer;
    /**
     * Find the largest of any number of [[SemVer]]s.
     *
     * @param versions the [[SemVer]]s for which to find the maximum
     */
    static max(versions: SemVer[]): SemVer;
    /**
     * Return the larger of two [[SemVer]]s.
     *
     * @param left a [[SemVer]]
     * @param right a [[SemVer]]
     */
    private static compare;
    constructor(major: number, minor: number, patch: number, info: string | null);
    /**
     * Return "true" if this is a "zero version".
     */
    isZero(): boolean;
    toString(): string;
}
/**
 * Given a file, perform replacements based on the [ReplacementMap] and write.
 *
 * @param filename the file's name
 * @param replacements the [Array] of [ReplacementMap]s
 */
export declare function rewriteFileContentsWithReplacements(filename: string, replacements: Array<ReplacementMap>): Promise<void>;
/**
 * Given a file, perform a single replacement based on the matcher and replacement.
 *
 * @param filename the file's name
 * @param matcher the matcher [RegExp]
 * @param replacement the replacement [string]
 */
export declare function rewriteFileContentsWithReplacement(filename: string, matcher: RegExp, replacement: string): Promise<void>;
/**
 * Given [string] of newline-delimited tags in text, find the latest tag and return it as [[SemVer]].
 *
 * Note the example: `1.0.0-rc2 < 1.0.0`.
 *
 * @param text the text with tags from which to find the latest SemVer version
 * @param stableOnly if the function should ignore all prerelease/build info-appended versions
 * @returns a SemVer representation as a 4-ary [Tuple] of 3 [number]s and 1 optional [string]
 */
export declare function findLatestSemVerUsingString(text: string, stableOnly: boolean): Promise<SemVer>;
/**
 * Using `git` tags, find the latest version (if this is possible).
 *
 * If no version is found, just return 0.0.0 with no info associated.
 *
 * @param stableOnly whether we should only extract stable versions
 */
export declare function findLatestVersionFromGitTags(stableOnly: boolean): Promise<SemVer>;
